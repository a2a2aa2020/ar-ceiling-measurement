<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ø§Ù„Ù‚ÙŠØ§Ø³ Ø§Ù„Ø°ÙƒÙŠ (Ø§Ù„Ù†Ø³Ø¨Ø© ÙˆØ§Ù„ØªÙ†Ø§Ø³Ø¨)</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; touch-action: none; }
        
        #video, #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #video { object-fit: cover; opacity: 0.7; }
        #canvas { z-index: 2; }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .header {
            background: linear-gradient(180deg, rgba(0,0,0,0.9), transparent);
            color: white; padding: 20px; text-align: center; pointer-events: auto;
        }

        .area-display {
            font-size: 42px; font-weight: bold; color: #00e676; 
            text-shadow: 0 2px 4px black; margin-bottom: 5px;
        }

        .footer {
            background: #1a1a1d; padding: 20px;
            border-radius: 25px 25px 0 0; pointer-events: auto;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
        }

        /* Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ */
        .input-wrapper {
            background: #333; padding: 15px; border-radius: 15px;
            border: 1px solid #555; margin-bottom: 15px;
            display: flex; align-items: center; justify-content: space-between;
        }

        .input-label { color: #aaa; font-size: 14px; }
        
        input[type="number"] {
            width: 100px; background: transparent; border: none; border-bottom: 2px solid #4facfe;
            color: white; font-size: 24px; font-weight: bold; text-align: center; outline: none;
        }

        .btn-cam {
            width: 100%; padding: 15px; border: none; border-radius: 12px;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white; font-size: 18px; font-weight: bold; cursor: pointer;
        }

        /* ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ù„ØµÙ‚Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ù… */
        .label-badge {
            font-family: Arial, sans-serif; font-weight: bold; font-size: 14px;
        }
    </style>
</head>
<body>

    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>

    <div class="ui-layer">
        <div class="header">
            <div class="area-display" id="areaText">0.00 Ù…Â²</div>
            <div style="font-size:13px; color:#ddd;">
                Ø­Ø¯Ø¯ Ø§Ù„Ø²ÙˆØ§ÙŠØ§ ğŸ‘ˆ Ø£Ø¯Ø®Ù„ Ø¹Ø±Ø¶Ø§Ù‹ ÙˆØ§Ø­Ø¯Ø§Ù‹ ğŸ‘ˆ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙŠØ­Ø³Ø¨ Ø§Ù„Ø¨Ø§Ù‚ÙŠ
            </div>
        </div>

        <div class="footer">
            <div class="input-wrapper">
                <div style="text-align: right;">
                    <div class="input-label">Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø±ÙˆÙ (Ø§Ù„Ø®Ø· Ø§Ù„Ø£Ø²Ø±Ù‚)</div>
                    <div style="font-size: 10px; color: #888;">Ø³ÙŠØªÙ… Ø­Ø³Ø§Ø¨ Ø§Ù„Ø·ÙˆÙ„ (Ø§Ù„Ø£Ø®Ø¶Ø±) ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹</div>
                </div>
                <div>
                    <input type="number" id="knownWidthInput" value="4.0" step="0.1" inputmode="decimal">
                    <span style="color: white; font-weight: bold;">Ù…ØªØ±</span>
                </div>
            </div>
            
            <button class="btn-cam" onclick="toggleCam()">ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ğŸ“·</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const widthInput = document.getElementById('knownWidthInput');
        const areaText = document.getElementById('areaText');

        let points = [];
        let draggingIdx = -1;

        // Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø­Ø³ÙˆØ¨Ø©
        let computedLength = 0;
        let computedArea = 0;

        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Ù†Ù‚Ø§Ø· Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const w = canvas.width * 0.5;
            const h = w * 0.75;

            points = [
                { x: cx - w/2, y: cy - h/2 }, // 0: Ø£Ø¹Ù„Ù‰ ÙŠØ³Ø§Ø±
                { x: cx + w/2, y: cy - h/2 }, // 1: Ø£Ø¹Ù„Ù‰ ÙŠÙ…ÙŠÙ†
                { x: cx + w/2, y: cy + h/2 }, // 2: Ø£Ø³ÙÙ„ ÙŠÙ…ÙŠÙ†
                { x: cx - w/2, y: cy + h/2 }  // 3: Ø£Ø³ÙÙ„ ÙŠØ³Ø§Ø±
            ];
            calculateAndDraw();
        }

        // --- Ø§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ (Core Logic) ---
        function calculateAndDraw() {
            // 1. Ø­Ø³Ø§Ø¨ Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„Ø¨ÙƒØ³Ù„ (Ø§Ù„Ù…ØªÙˆØ³Ø·Ø§Øª Ù„ØªÙ‚Ù„ÙŠÙ„ Ø®Ø·Ø£ Ø§Ù„Ù…Ù†Ø¸ÙˆØ±)
            // Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù„ÙˆÙŠ Ø¨Ø§Ù„Ø¨ÙƒØ³Ù„
            const topPx = Math.hypot(points[1].x - points[0].x, points[1].y - points[0].y);
            // Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø³ÙÙ„ÙŠ Ø¨Ø§Ù„Ø¨ÙƒØ³Ù„
            const bottomPx = Math.hypot(points[2].x - points[3].x, points[2].y - points[3].y);
            // Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…ØªÙˆØ³Ø· Ø¨Ø§Ù„Ø¨ÙƒØ³Ù„
            const avgWidthPx = (topPx + bottomPx) / 2;

            // Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ø£ÙŠÙ…Ù† Ø¨Ø§Ù„Ø¨ÙƒØ³Ù„
            const rightPx = Math.hypot(points[2].x - points[1].x, points[2].y - points[1].y);
            // Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ø£ÙŠØ³Ø± Ø¨Ø§Ù„Ø¨ÙƒØ³Ù„
            const leftPx = Math.hypot(points[3].x - points[0].x, points[3].y - points[0].y);
            // Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ù…ØªÙˆØ³Ø· Ø¨Ø§Ù„Ø¨ÙƒØ³Ù„
            const avgHeightPx = (rightPx + leftPx) / 2;

            // 2. Ø§Ù„Ù†Ø³Ø¨Ø© ÙˆØ§Ù„ØªÙ†Ø§Ø³Ø¨ (Aspect Ratio)
            // Ù‡Ø°Ù‡ Ø§Ù„Ù†Ø³Ø¨Ø© ØªØ®Ø¨Ø±Ù†Ø§: "ÙƒÙ… Ù…Ø±Ø© Ø§Ù„Ø·ÙˆÙ„ Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ø¹Ø±Ø¶ ÙÙŠ Ø§Ù„Ø±Ø³Ù…Ø©ØŸ"
            const ratio = avgHeightPx / avgWidthPx;

            // 3. ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª
            const knownW = parseFloat(widthInput.value) || 0;
            
            // 4. Ø§Ø³ØªÙ†ØªØ§Ø¬ Ø§Ù„Ø·ÙˆÙ„ ÙˆØ§Ù„Ù…Ø³Ø§Ø­Ø©
            // Ø§Ù„Ø·ÙˆÙ„ = Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø±ÙˆÙ * Ø§Ù„Ù†Ø³Ø¨Ø©
            computedLength = (knownW * ratio).toFixed(2);
            computedArea = (knownW * computedLength).toFixed(2);

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø´Ø§Ø´Ø©
            areaText.innerText = computedArea + ' Ù…Â²';
            
            draw(knownW, computedLength);
        }

        function draw(widthVal, lengthVal) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Ø±Ø³Ù… Ø§Ù„Ù…Ø¶Ù„Ø¹
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            
            ctx.fillStyle = 'rgba(79, 172, 254, 0.15)';
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#4facfe'; // Ù„ÙˆÙ† Ø§Ù„Ø­Ø¯ÙˆØ¯
            ctx.stroke();

            // Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø§Ø·
            points.forEach((p, i) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = (i === draggingIdx) ? '#ff5858' : 'white';
                ctx.fill();
                ctx.strokeStyle = '#4facfe';
                ctx.stroke();
            });

            // --- Ø±Ø³Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø°ÙƒÙŠØ© ---
            
            // 1. Ø§Ù„Ø£Ø¶Ù„Ø§Ø¹ Ø§Ù„Ø£ÙÙ‚ÙŠØ© (Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¯Ø®Ù„) - Ù„ÙˆÙ† Ø£Ø²Ø±Ù‚
            drawLabel(points[0], points[1], widthVal + 'm', '#4facfe', true); // Ø£Ø¹Ù„Ù‰
            drawLabel(points[3], points[2], widthVal + 'm', '#4facfe', true); // Ø£Ø³ÙÙ„

            // 2. Ø§Ù„Ø£Ø¶Ù„Ø§Ø¹ Ø§Ù„Ø±Ø£Ø³ÙŠØ© (Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ù…Ø­Ø³ÙˆØ¨) - Ù„ÙˆÙ† Ø£Ø®Ø¶Ø± (Ù„ØªÙ…ÙŠÙŠØ² Ø£Ù†Ù‡ Ù†ØªÙŠØ¬Ø©)
            drawLabel(points[1], points[2], lengthVal + 'm', '#00e676', false); // ÙŠÙ…ÙŠÙ†
            drawLabel(points[0], points[3], lengthVal + 'm', '#00e676', false); // ÙŠØ³Ø§Ø±
        }

        function drawLabel(p1, p2, text, color, isInput) {
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            
            ctx.save();
            ctx.font = 'bold 16px Arial';
            const w = ctx.measureText(text).width + 25;
            const h = 30;

            // Ø®Ù„ÙÙŠØ© Ø§Ù„Ù†Øµ
            ctx.fillStyle = '#1e1e24';
            ctx.beginPath();
            ctx.roundRect(midX - w/2, midY - h/2, w, h, 8);
            ctx.fill();
            
            // Ø­Ø¯ÙˆØ¯ Ù…Ù„ÙˆÙ†Ø©
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Ø£ÙŠÙ‚ÙˆÙ†Ø© ØµØºÙŠØ±Ø© Ù„Ù„Ù…Ø¯Ø®Ù„Ø§Øª (Ù‚Ù„Ù…) Ø£Ùˆ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ (Ù‚ÙÙ„)
            const icon = isInput ? 'âœï¸' : 'ğŸ”—';
            
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(icon + ' ' + text, midX, midY + 1);
            
            ctx.restore();
        }

        // --- Ø§Ù„ØªÙØ§Ø¹Ù„ ---
        function getPos(e) {
            const t = e.touches ? e.touches[0] : e;
            return { x: t.clientX, y: t.clientY };
        }

        function onDown(e) {
            const pos = getPos(e);
            let closest = 50, idx = -1;
            points.forEach((p, i) => {
                if(Math.hypot(p.x - pos.x, p.y - pos.y) < closest) { closest = Math.hypot(p.x - pos.x, p.y - pos.y); idx = i; }
            });
            if(idx !== -1) { draggingIdx = idx; calculateAndDraw(); }
        }

        function onMove(e) {
            if (draggingIdx === -1) return;
            e.preventDefault();
            const pos = getPos(e);
            points[draggingIdx].x = pos.x;
            points[draggingIdx].y = pos.y;
            calculateAndDraw();
        }

        function onUp() { draggingIdx = -1; calculateAndDraw(); }

        canvas.addEventListener('mousedown', onDown);
        canvas.addEventListener('touchstart', onDown, { passive: false });
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('touchmove', onMove, { passive: false });
        window.addEventListener('mouseup', onUp);
        window.addEventListener('touchend', onUp);

        // ØªØ­Ø¯ÙŠØ« Ø¹Ù†Ø¯ Ø§Ù„ÙƒØªØ§Ø¨Ø©
        widthInput.addEventListener('input', calculateAndDraw);

        async function toggleCam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                video.srcObject = stream;
            } catch(e) { alert("HTTPS Required"); }
        }

        window.onresize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; calculateAndDraw(); };
        toggleCam();
        initCanvas();
    </script>
</body>
</html>
